/*
IMPORTANTE: 

-Este fichero modificado para soportar nombres multiples y algun metodo adicional. 
	Lo de los nombres ES NECESARIO por el tema de UNIX.
-Este fichero NO se genera cada vez que compilamos, si no que es fijo, lo cual es ideal para 
	meter cambios que perduran. 

*/

// $Header: FlexLexer.h,v 1.2 94/01/04 14:57:26 vern Exp $

// FlexLexer.h -- define classes for lexical analyzers generated by flex

// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams and Tom Epperly.
//
// Redistribution and use in source and binary forms are permitted provided
// that: (1) source distributions retain this entire copyright notice and
// comment, and (2) distributions including binaries display the following
// acknowledgement:  ``This product includes software developed by the
// University of California, Berkeley and its contributors'' in the
// documentation or other materials provided with the distribution and in
// all advertising materials mentioning features or use of this software.
// Neither the name of the University nor the names of its contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

#ifndef __FLEX_LEXER_H
#define __FLEX_LEXER_H

#include "m4stl.hpp"

// ESTOS DEFINES ....

#define yyFlexLexer ClRFN_FlexLexer
#define yy_create_buffer ClRFN__create_buffer
#define yy_delete_buffer ClRFN__delete_buffer
#define yy_flex_debug ClRFN__flex_debug
#define yy_init_buffer ClRFN__init_buffer
#define yy_load_buffer_state ClRFN__load_buffer_state
#define yy_switch_to_buffer ClRFN__switch_to_buffer
#define yyin ClRFN_in
#define yyleng ClRFN_leng
#define yylex ClRFN_lex
#define yyout ClRFN_out
#define yyrestart ClRFN_restart
#define yytext ClRFN_text
#define yywrap ClRFN_wrap

//  ... son necesarios para que el cambio de nombre de clase sea visto por otros modulos.



// This file defines two classes.  The first, FlexLexer, is an abstract
// class which specifies the external interface provided to flex C++
// lexer objects.  The second, yyFlexLexer, fills out most of the meat
// of the lexer class; its internals may vary from lexer to lexer
// depending on things like whether REJECT is used.
//
// If you want to create multiple lexer classes, you use the -P flag
// to rename each yyFlexLexer to some other xxFlexLexer.

extern "C++" {

struct yy_buffer_state;
typedef int yy_state_type;

// ESTO  ....

#include "rfn.h"
#include "rfndf.inl"
#include "rfnparser.h"

class ClRFN_ParserTree ;
class ClRFN_Parser ;

//	.... es necesario para la clase ampliada 



class FlexLexer {
public:
	virtual ~FlexLexer()	{ }

	const char* YYText()	{ return yytext; }
	int YYLeng()		{ return yyleng; }

	virtual void
		yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
	virtual struct yy_buffer_state*
		yy_create_buffer( istream* s, int size ) = 0;
	virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
	virtual void yyrestart( istream* s ) = 0;

	virtual int yylex() = 0;

protected:
	char* yytext;
	int yyleng;
};


class yyFlexLexer : public FlexLexer {

private:

	// ESTO  ....


	ClRFN_ParsePAR *PAR ; //Simple Link
	ClRFN_Parser   *Parser ;	//Simple Link

public:

	void LinkParserPAR(ClRFN_ParsePAR *ai_PAR) { PAR=ai_PAR ; }
	void LinkParser(ClRFN_Parser *ai_Parser) { Parser=ai_Parser ; }

	//	.... es necesario para poder poner simbolos

public:
	// arg_yyin and arg_yyout default to the cin and cout, but we
	// only make that assignment when initializing in yylex().
	yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )
		{
		yyin = arg_yyin;
		yyout = arg_yyout;
		yy_c_buf_p = 0;
		yy_init = 1;
		yy_start = 0;

		yy_did_buffer_switch_on_eof = 0;

		yy_looking_for_trail_begin = 0;
		yy_more_flag = 0;
		yy_more_len = 0;

		yy_start_stack_ptr = yy_start_stack_depth = 0;
		yy_start_stack = 0;

		yy_current_buffer = 0;

#ifdef YY_USES_REJECT
		yy_state_buf = new yy_state_type[YY_BUF_SIZE + 2];
#else
		yy_state_buf = 0;
#endif
		}

	virtual ~yyFlexLexer()
		{
		delete yy_state_buf;
		}

	void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
	struct yy_buffer_state* yy_create_buffer( istream* s, int size );
	void yy_delete_buffer( struct yy_buffer_state* b );
	void yyrestart( istream* s );

	virtual int yylex();

	int ClRFN_wrap(void) { return 1 ; }

	protected:
	virtual int LexerInput( char* buf, int max_size );
	virtual void LexerOutput( const char* buf, int size );
	virtual void LexerError( const char* msg );

	void yyunput( int c, char* buf_ptr );
	int yyinput();

	void yy_load_buffer_state();
	void yy_init_buffer( struct yy_buffer_state* b, istream* s );

	int yy_start_stack_ptr;
	int yy_start_stack_depth;
	int* yy_start_stack;

	void yy_push_state( int new_state );
	void yy_pop_state();
	int yy_top_state();

	yy_state_type yy_get_previous_state();
	yy_state_type yy_try_NUL_trans( yy_state_type current_state );
	int yy_get_next_buffer();

	istream* yyin;	// input source for default LexerInput
	ostream* yyout;	// output sink for default LexerOutput

	struct yy_buffer_state* yy_current_buffer;

	// yy_hold_char holds the character lost when yytext is formed.
	char yy_hold_char;

	// Number of characters read into yy_ch_buf.
	int yy_n_chars;

	// Points to current character in buffer.
	char* yy_c_buf_p;

	int yy_init;		// whether we need to initialize
	int yy_start;		// start state number

	// Flag which is used to allow yywrap()'s to do buffer switches
	// instead of setting up a fresh yyin.  A bit of a hack ...
	int yy_did_buffer_switch_on_eof;

	// The following are not always needed, but may be depending
	// on use of certain flex features (like REJECT or yymore()).

	yy_state_type yy_last_accepting_state;
	char* yy_last_accepting_cpos;

	yy_state_type* yy_state_buf;
	yy_state_type* yy_state_ptr;

	char* yy_full_match;
	int* yy_full_state;
	int yy_full_lp;

	int yy_lp;
	int yy_looking_for_trail_begin;

	int yy_more_flag;
	int yy_more_len;
};

}

#endif
